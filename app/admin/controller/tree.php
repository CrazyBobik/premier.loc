<?phpdefined('K_PATH') or die('DIRECT ACCESS IS NOT ALLOWED');class Admin_Controller_Tree extends Controller {    /* {public} */    public $layout = 'layout';    protected $treeTable;    public function onInit() {        $this->treeTable = new K_Tree_Model();    }    /* {actions} */    public function indexAction() {        $this->getAction();    }    /*        Returns data for client-side tree        var data = [    {    label: 'Тест',    children: [    { label: 'child1' },    { label: 'child2' }    ]    },    {    label: 'Тест 2',    children: [    { label: 'child3' }    ]    }    ];        */    public function getAction() {	        $this->disableRender = true;        $query = new K_Db_Query;        $treeStructure = array();        $treeElements = array();        if ($this->getParam('pid')) {                        $nodeId = $this->getParam('pid');                    } else {                        $nodeId = 0;                                       }				// Прийдётся лезть в тип списка 				$pidType = K_TreeQuery::gOne((int)$nodeId); 				//var_dump($pidType);				if($pidType['sorted']=="По алфавиту"){						$order = "`t1`.`tree_title`";						}else{					$order = "`t1`.`tree_lkey`";				}	        $sql = 'SELECT `t1`.*, COUNT(`t2`.`tree_id`) as subElements FROM `tree` as `t1` 				LEFT JOIN `tree` as `t2` ON `t2`.`tree_pid` = `t1`.`tree_id`				WHERE `t1`.`tree_pid`=' . (int)$nodeId . '				GROUP BY `t1`.`tree_id`, `t1`.`tree_pid`, `t1`.`tree_title`				ORDER BY '.$order;        $treeElements = $query->q($sql);        foreach ($treeElements as $key => $column) {            $treeElements[$key] = $column->toArray();        }       if ($nodeId!='0') {	   			$nodeArr = K_tree::getParents($nodeId); // выбираем всех родителей ноды			$nodeArr[] = $nodeId; // добовляем id самой ноды			// проверяем на доступ ноду со всеми её родителями к которой запрашиваються потомки			/* foreach ( $pid_node_perents as $v ) {			if ( is_string( $v ) ) {			$resourse_arr[] = $v;			$resourse = 't:' . implode( '/', $resourse_arr );			// echo $resourse;			try {			$access = K_Access::acl()->isAllowed( K_Auth::getRoles(), $resourse, 'view' );			// var_dump($access);			}			catch ( exception $e ) {			$access = $allow_trigger;			}			$allow_trigger = $access;			}			}*/			//строим ресур запрашиваемой ноды если нода не равна 0			    $allowTrigger = false;				$access = false;				$_nodeArr=$nodeArr;				 				for ($i = count($_nodeArr); $i > 0; $i--) {					$resourse = implode('/', $_nodeArr);					array_pop($_nodeArr);					$access = K_Access::aclTree()->isAllowed(K_Auth::getRoles(), $resourse, true);					if (K_Access::aclTree()->lastResource) {						break;					}				}				$allowTrigger = $access;                   } else {            $allowTrigger = true;            $nodeArr=array();        }                        for ($i = 0; $i < sizeof($treeElements); $i++) {                        $typeController = 'Type_Controller_' .ucfirst($treeElements[$i]['tree_type']);            $resArr=$nodeArr;            $resArr[]=$treeElements[$i]['tree_id'];            $resourse = implode('/', $resArr);           //  echo $resourse."\n";            $access = K_Access::aclTree()->isAllowed(K_Auth::getRoles(), $resourse, true);                      // var_dump(K_Access::aclTree()->lastResource);                if (K_Access::aclTree()->lastResource == null) {                   $access = $allowTrigger;                }                      if($access || $treeElements[$i]['tree_id']=='1' ){                          if($treeElements[$i]['subElements']){                  $nodeState= 'closed';               }else{                  $nodeState='';               }                             if($treeElements[$i]['tree_type']=='list'){                $list = K_CupItems::getItems($treeElements[$i]['tree_id'],$treeElements[$i]['tree_type']);                $allowTypes = array_map('trim', explode(',', $list[0]['types']));              }else{              $allowTypes=$typeController::$allowedChildren;              }                                          if(!in_array("all", $allowTypes))                $allows = array("types"=>array("valid_children" =>$allowTypes));                               $treeStructure=array(                        'attr'=>array(                                        'id'=>'node_'.$treeElements[$i]['tree_id'],                                        'rel'=>$access ? $treeElements[$i]['tree_type']:"disable_n"),                                                                 'data'=>array(                                   "title" => $treeElements[$i]['tree_title'].' -> '.$treeElements[$i]['tree_name'],                                    'icon'=>"/adm/img/tree/".$treeElements[$i]['tree_type'].".png",                                   "attr" => array("href" =>"#","class"=> $access ? "":"ui-state-disabled"),                             ),                         "metadata" =>array('id' => $treeElements[$i]['tree_id']),                        'state'=>$nodeState                );                 $treeStructure['metadata']["jstree"]=$allows;                                      $treeStructureArr[]=$treeStructure;                                 // $treeStructure['metadata']['jstree']=$allows;                               };                       };         $this->putJSON($treeStructureArr);    }    /*    Перемещяет нод в дереве    $key, $base_key, $position = 'bottom'    */    public function moveAction() {     	 		         $this->disableRender = true;        $key = (int)$_POST['key'];        $baseKey = (int)$_POST['base_key'];        $position = $_POST['position'];        $copy = (int)$_POST['copy'];        $pasteKey = (int)$_POST['parent_key'];        	    $node = K_Tree::getNode($key); 		        if($node['tree_bloked']=='1'){					   $this->putAjax('{ "status" : false}');				}		       if($copy){           if(!K_access::accessTree($key,array('add','addremove'),true)){            $this->putAjax('{ "status" : false}');           }        }else{           if(!K_access::accessTree($key,array('addremove'),true)){            $this->putAjax('{ "status" : false}');           }        }             if (($baseKey == 1 && ($position == 'after' || $position == 'before')) || ($key == 1) || $baseKey==$key  ) {        } else {                     if($copy){                        $returnJson = K_CupTree::сNode($key,$pasteKey);            $returnJson['status']=1;            echo json_encode($returnJson);                       }else{            //рессурс ноды до перемещения            $nodeParentsArr = K_Tree::getParents($key);            $nodeParentsArr[] = $key;            $beforeMove = implode('/', $nodeParentsArr);            if (K_Tree::move($key, $baseKey, ($position == 'last' ? 'top' : $position))) {                //рессурс после перемещения                $nodeParentsArr = K_Tree::getParents($key);                $nodeParentsArr[] = $key;                $afterMove = implode('/', $nodeParentsArr);                // если рессурсы отличаються то перезагружаем ветку ACL                if ($afterMove != $beforeMove) {                    //удаляем старую ветку рессурсов                    K_access::aclTree()->remove($beforeMove);                    $node = K_Tree::getNode($key);                    $query = new K_Db_Query;                    $sql = "SELECT DISTINCT tree_rule.tree_rule_id as tree_ruleId, tree_rule.tree_rule_resource_id, tree_rule.tree_rule_type as tree_ruleType, role.role_acl_key as role, privilege.privilege_name as privilege                       FROM tree_rule, role, tree, privilege                       WHERE tree.tree_lkey >= " . (int)$node['tree_lkey'] . " AND tree.tree_rkey <= " . (int)$node['tree_rkey'] . "                            and tree_rule.tree_rule_status = 1                                     and role.role_status = 1                           and privilege.privilege_status = 1                           and tree_rule.tree_rule_role_id = role.role_id                           and tree_rule.tree_rule_resource_id = tree.tree_id                           and tree_rule.tree_rule_privilege_id = privilege.privilege_id                           ORDER BY tree_rule.tree_rule_order";                    $allRules = $query->q($sql);                    K_Access::aclTreeReloadBrunch($allRules);                }                       echo '{ "status" : 1}';              } else {                echo 'false';            }          }        }    }    public function removeAction() {        $this->disableRender = true;           $nodeId = (int)$this->getParam('id');        $returnJson=array();				$node = K_Tree::getNode($nodeId);				if($node['tree_bloked']=='1'){					   $returnJson['status']=false;		   $this->putJSON($returnJson);		   		}		                  if (K_access::accessTree($nodeId,array('addremove'),true) && K_CupTree::dNodes($nodeId))         {            $returnJson['status']=true;        } else {            $returnJson['status']=false;        }                $this->putJSON($returnJson);    }    public function updateAction() {	        $this->disableRender = true;        $nodeId = (int)$this->getParam('id');				$node = K_Tree::getNode($nodeId); 		        if($node['tree_bloked']=='1' ||  $nodeId=='1' ){					echo 'Этот элемент заблокирован!			 <script type="text/javascript">	    		    enableTree();                $.jstree._reference(\'#tree\').set_text( $(\'#node_{$nodeId}\') ,"{$updateValues[\'tree_title\']}");            	$(".node_information-{$nodeId}").find("b").text("{$newTreeLink}");             </script>';          		     return;		}        $treeTable = new K_Tree_Model();        $updateValues = array();        if (isset($_POST['tree_title']) && ! empty($_POST['tree_title'])) {            $updateValues['tree_title'] = $_POST['tree_title'];        }        if (isset($_POST['tree_name']) && ! empty($_POST['tree_name'])) {            $updateValues['tree_name'] = preg_replace("/[^a-z0-9,-]/i", "", $_POST['tree_name']);            $updateValues['tree_title'] = preg_replace("/[\"']/i", "", $_POST['tree_title']);             if (strlen($updateValues['tree_name']) < 1) {                throw new Exception('Название элемента не соответствует');            }            $nodeData = K_Tree::getNode($nodeId);            $partsOfLink = explode('/', substr($nodeData['tree_link'], 0, -1));            $newTreeLink = $nodeData['tree_link'];            if ($partsOfLink) {                $partsOfLink[(sizeof($partsOfLink) - 1)] = $updateValues['tree_name'];                $newTreeLink = implode('/', $partsOfLink) . '/';            }            $query = new K_Db_Query;            $query->q('UPDATE `tree` SET `tree_link` = CONCAT(REPLACE(LEFT(tree_link, ' . strlen($nodeData['tree_link']) . '), "' . $nodeData['tree_link'] . '", "' . $newTreeLink . '"), SUBSTRING(tree_link, ' . (strlen($nodeData['tree_link']) + 1) . ')) WHERE `tree_lkey`>=' . $nodeData['tree_lkey'] . ' AND `tree_rkey`<=' . $nodeData['tree_rkey']);        }        $treeTable->update($updateValues, '`tree_id` = ' . $nodeId);        echo <<< HTML		Элемент успешно обновлён!        <script type="text/javascript">			  enableTree();        $.jstree._reference('#tree').set_text( $('#node_{$nodeId}') ,"{$updateValues['tree_title']}");    	//	$("#tree.node_{$nodeId}").find(".title:first").text("{$updateValues['tree_title']}");			$(".node_information-{$nodeId}").find("b").text("{$newTreeLink}");        </script>HTML;    }    public function updateseoAction(){	        $this->disableRender = true;        $nodeId = (int)$this->getParam('id');		        $data = array('tree_meta_title'=>strip_tags(trim($_POST['title'])),                      'tree_meta_description'=>strip_tags(trim($_POST['description'])),					  'tree_meta_canonical'=>strip_tags(trim($_POST['canonical'])),                      'tree_meta_keywords'=>strip_tags(trim($_POST['keywords'])),                      'tree_meta_title_uk'=>strip_tags(trim($_POST['title_uk'])),                      'tree_meta_keywords_uk'=>strip_tags(trim($_POST['keywords_uk'])),                      'tree_meta_description_uk'=>strip_tags(trim($_POST['description_uk'])),			          'tree_meta_canonical_uk'=>strip_tags(trim($_POST['canonical_uk']))					  );                $treeTable = new K_Tree_Model();        $treeTable->update($data, '`tree_id` = ' . $nodeId);                $jsonReturn['error'] = false;        $jsonReturn['msg'] = "Сео данные успешно обновлены!";        $jsonReturn['callback']='function callback(){enableTree();}';                     if (K_Request::isAjax()) {               $this->putJSON($jsonReturn);           } else {               K_Request::redirect('/');           }     }    public function addAction() {        $this->disableRender = true;        $nodeId = (int)$this->getParam('pid');        $allowedkeys = array(            'tree_type',            'tree_name',            'tree_title',            );        $values = array();        foreach ($_POST as $elementKey => $elementValue) {            if (in_array($elementKey, $allowedkeys)) {                if (is_string($elementValue)) {                    $elementValue = trim($elementValue);                }                $values[$elementKey] = $elementValue;                if ($elementKey == 'tree_name') {                    $values[$elementKey] = preg_replace("/[^a-z0-9-]/i", "", $elementValue);                    if (empty($values[$elementKey])) {                        $this->putAJAX("Название нового элемента не соответствует!");                    }                }                if ($elementKey == 'tree_title') {                    $values[$elementKey] = preg_replace("/[\"']/i", "", $elementValue);                    if (empty($values[$elementKey])) {                        $this->putAJAX("Заголовок нового элемента не может содержать ковычки!");                    }                }                if ($elementKey == 'tree_type') {                    $nodeData = K_Tree::getNode($nodeId);                    $nodeType = $nodeData['tree_type'];                    $typeClass = 'Type_Controller_' . ucfirst($nodeType);                    if (isset($typeClass::$allowedChildren[0])) {                        if ((($typeClass::$allowedChildren[0] == 'all') && (sizeof($typeClass::$allowedChildren) == 1)) || (($typeClass::$allowedChildren[0] == 'all') && ! in_array($elementValue, $typeClass::$allowedChildren)) || (($typeClass::$allowedChildren[0] != 'all') && in_array($elementValue, $typeClass::$allowedChildren))) {                            $values[$elementKey] = $elementValue;                        } else {                           $this->putAJAX("Тип " . $elementValue . " не может быть дочерним у типа " . $nodeType . "!");                        }                    } else {                       $this->putAJAX("Тип " . $elementValue . " не может быть дочерним у типа " . $nodeType . "!");                    }                }            }        }        if (sizeof($values) == 3) {               $newNodeId=K_Tree::add($nodeId, $values['tree_type'], $values['tree_name'], $values['tree_title']);               $nodeArr=array(                            'attr'=>array(                                            'id'=>'node_'.$newNodeId,                                            'rel'=>$values['tree_type']),                                                                         'data'=>array(                                       "title" => $values['tree_title'],                                        'icon'=>"/adm/img/tree/".$values['tree_type'].".png",                                ),                             "metadata" =>array('id' =>$newNodeId['tree_id']),                            'state'=>''                          );                                 $typeController = 'Type_Controller_'.ucfirst($values['tree_type']);           $nodeArr['metadata']["jstree"] = array("types"=>array("valid_children" =>$typeController::$allowedChildren));           $nodeObj=json_encode($nodeArr);                      echo <<< HTML			Элемент успешно добавлен!			<script type="text/javascript">			   enableTree();         		$('#tree_name').value = '';			   	$('#tree_title').value = '';                $("#tree").jstree("create",'#node_$nodeId','inside',$nodeObj,function(){                                                                                 $('#node_$newNodeId a').click();                                                                                },true);               //selectedNodeReload($('#node_$nodeId'),'#node_$newNodeId');               //$.jstree._reference('#node_$nodeId').create({ attributes : { 'class' : 'cc' }, data: { title : 'ID and ICON', icon : '../media/images/ok.png' }});               // $.jstree._reference('#tree').create_node({ attributes : { 'class' : 'cc' }, data: { title : 'ID and ICON', icon : '../media/images/ok.png' } },$('#node_$nodeId'));               // $.jstree._reference('#node_$nodeId').set_focus();            </script>HTML;        }    }}